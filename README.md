# designpattern
设计模式小结
*****
# 简单工厂模式
简单工厂模式主要思想是创建一个工厂（Factory）类，该工厂类可以创建一系列相近的类的对象。在该工厂中可以根据调用者传入的参数，完成各个不同对象的创建工作。用户希望获得某个具体类的时候，只需要调用该工厂类，并输入对应的入参即可，用户无需知道具体子类的名称，不用new 子类来创建子类对象，而都是通过工厂的方法来创建对象。

通过工厂模式，用户可以只关注工厂类的接口，按照接口传入具体类的相关参数即可，而无需直接new子类产生对象，也无需关注创建对象的具体实施细节。这样的话，当子类的名称改变时，我们就不用在每一处创建子类对象的地方都相应的该名称了，只要在工厂类里面做一处改动即可。

缺点是当具体类太多，工厂创建子类对象的业务逻辑太复杂时，工厂类会变得异常庞大臃肿，增加耦合度。而且当增加新的子类时，都需要修改简单工厂的代码，增加逻辑判断，违反“开-闭”原则。

## 工厂方法模式
为了解决简单工厂模式代码臃肿的问题，可以采用工厂方法模式。工厂方法模式的思想是，取代简单工厂的多个类对应一个工厂的方式，用一个类对应一个工厂，所以有很多工厂，这些工厂都实现自接口，接口中都有产生对象的方法。所以只需要在各自的工厂重写这个方法，分别增添业务逻辑即可。

判断应该选择哪个工厂的逻辑就调用者完成，然后所选择的工厂就可以产生相应对象。（简单工厂则是在工厂类中判断产生哪个子类）。

工厂方法的好处是，各个工厂的业务代码分别放在了不同的工厂类中，不会像简单工厂一样，很多代码耦合在一个工厂类中。而且增加子类时只需增加抽象接口的实现即可，判断的逻辑在客户端，不违反“开-闭”原则。

缺点是每增加一个产品，就要增加工厂，加大开发量。

## 抽象工厂模式
抽象工厂模式是建立在简单工厂模式之上的。一系列相近的类（产品）属于一个工厂，当有多个产品族而且用户一次只使用一族产品时，就需要多个工厂，就需要建立抽象工厂来组织这些工厂。

思路是，创建一个抽象工厂（AbstractFactory），该抽象工厂包含有获取每个具体工厂的类的对象的抽象方法；各个具体的工厂继承该抽象工厂，同时重写本工厂的产生具体类对象的方法。
